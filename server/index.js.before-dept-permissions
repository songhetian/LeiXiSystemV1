const fastify = require('fastify')({
  logger: true,
  bodyLimit: 10485760 // 10MB
})
const cors = require('@fastify/cors')
const multipart = require('@fastify/multipart')
const mysql = require('mysql2/promise')
const bcrypt = require('bcryptjs')
const jwt = require('jsonwebtoken')
const fs = require('fs')
const path = require('path')
const { pipeline } = require('stream')
const util = require('util')
const pump = util.promisify(pipeline)
require('dotenv').config()

// æ³¨å†Œ CORS
fastify.register(cors, {
  origin: '*'
})

// æ³¨å†Œæ–‡ä»¶ä¸Šä¼ 
// æ³¨æ„ï¼šmultipart åªå¤„ç† multipart/form-dataï¼Œä¸å½±å“ application/json
fastify.register(multipart, {
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB
  }
})

// æ·»åŠ è¯·æ±‚æ—¥å¿—é’©å­ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
fastify.addHook('onRequest', async (request, reply) => {
  if (request.url.includes('/api/knowledge/articles') && (request.method === 'PUT' || request.method === 'POST')) {
    console.log('========================================')
    console.log(`[${request.method}] ${request.url}`)
    console.log('Content-Type:', request.headers['content-type'])
    console.log('Content-Length:', request.headers['content-length'])
    console.log('========================================')
  }
})

fastify.addHook('preHandler', async (request, reply) => {
  if (request.url.includes('/api/knowledge/articles') && (request.method === 'PUT' || request.method === 'POST')) {
    console.log('========================================')
    console.log('preHandler - Body è°ƒè¯•ä¿¡æ¯')
    console.log('Body type:', typeof request.body)
    console.log('Body is null:', request.body === null)
    console.log('Body is undefined:', request.body === undefined)
    console.log('Body keys:', request.body ? Object.keys(request.body) : 'N/A')
    console.log('Raw body:', JSON.stringify(request.body))
    console.log('========================================')
  }
})

// åˆ›å»ºä¸Šä¼ ç›®å½•
const uploadDir = path.join(__dirname, '../uploads')
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true })
}

// é™æ€æ–‡ä»¶æœåŠ¡
fastify.register(require('@fastify/static'), {
  root: uploadDir,
  prefix: '/uploads/'
})

// JWT å¯†é’¥
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

// æ•°æ®åº“é…ç½®
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'root',
  database: process.env.DB_NAME || 'leixin_customer_service',
  port: process.env.DB_PORT || 3306,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  timezone: '+08:00'  // è®¾ç½®ä¸ºåŒ—äº¬æ—¶é—´
}

let pool

// åˆå§‹åŒ–æ•°æ®åº“è¿æ¥æ± 
async function initDatabase() {
  try {
    pool = mysql.createPool(dbConfig)

    // è®¾ç½®æ—¶åŒºä¸ºåŒ—äº¬æ—¶é—´
    const connection = await pool.getConnection()
    await connection.query("SET time_zone = '+08:00'")
    connection.release()
    console.log('âœ… æ•°æ®åº“æ—¶åŒºå·²è®¾ç½®ä¸º +08:00')

    // å°† pool è£…é¥°åˆ° fastify å®ä¾‹ä¸Šï¼Œä¾›è·¯ç”±ä½¿ç”¨
    fastify.decorate('mysql', pool)
    console.log('âœ… æ•°æ®åº“è¿æ¥æ± å·²å°±ç»ª')
  } catch (error) {
    console.error('âŒ æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error)
  }
}

// å¥åº·æ£€æŸ¥
fastify.get('/api/health', async (request, reply) => {
  return { status: 'ok', message: 'æœåŠ¡æ­£å¸¸' }
})

// ==================== æ–‡ä»¶ä¸Šä¼  API ====================

// å•ä¸ªæ–‡ä»¶ä¸Šä¼ 
fastify.post('/api/upload', async (request, reply) => {
  try {
    const data = await request.file()

    if (!data) {
      return reply.code(400).send({ error: 'æ²¡æœ‰ä¸Šä¼ æ–‡ä»¶' })
    }

    // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
    const timestamp = Date.now()
    const randomStr = Math.random().toString(36).substring(7)
    const ext = path.extname(data.filename)
    const filename = `${timestamp}-${randomStr}${ext}`
    const filepath = path.join(uploadDir, filename)

    // ä¿å­˜æ–‡ä»¶
    await pump(data.file, fs.createWriteStream(filepath))

    // è¿”å›æ–‡ä»¶URL
    const fileUrl = `http://localhost:3001/uploads/${filename}`

    return {
      success: true,
      url: fileUrl,
      filename: data.filename,
      size: fs.statSync(filepath).size
    }
  } catch (error) {
    console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error)
    return reply.code(500).send({ error: 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥' })
  }
})

// æ‰¹é‡æ–‡ä»¶ä¸Šä¼ 
fastify.post('/api/upload/multiple', async (request, reply) => {
  try {
    const parts = request.parts()
    const uploadedFiles = []

    for await (const part of parts) {
      if (part.file) {
        // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
        const timestamp = Date.now()
        const randomStr = Math.random().toString(36).substring(7)
        const ext = path.extname(part.filename)
        const filename = `${timestamp}-${randomStr}${ext}`
        const filepath = path.join(uploadDir, filename)

        // ä¿å­˜æ–‡ä»¶
        await pump(part.file, fs.createWriteStream(filepath))

        // æ”¶é›†ç»“æœ
        uploadedFiles.push({
          url: `http://localhost:3001/uploads/${filename}`,
          filename: part.filename,
          size: fs.statSync(filepath).size
        })
      }
    }

    return {
      success: true,
      files: uploadedFiles
    }
  } catch (error) {
    console.error('æ‰¹é‡ä¸Šä¼ å¤±è´¥:', error)
    return reply.code(500).send({ error: 'æ‰¹é‡ä¸Šä¼ å¤±è´¥' })
  }
})

// ==================== è®¤è¯ API ====================

// ç”¨æˆ·æ³¨å†Œ
fastify.post('/api/auth/register', async (request, reply) => {
  const { username, password, real_name, email, phone } = request.body

  try {
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    const [existing] = await pool.query('SELECT id FROM users WHERE username = ?', [username])
    if (existing.length > 0) {
      return reply.code(400).send({ success: false, message: 'ç”¨æˆ·åå·²å­˜åœ¨' })
    }

    // åŠ å¯†å¯†ç 
    const passwordHash = await bcrypt.hash(password, 10)

    // æ³¨å†Œç”¨æˆ·
    const [result] = await pool.query(
      'INSERT INTO users (username, password_hash, real_name, email, phone, status) VALUES (?, ?, ?, ?, ?, ?)',
      [username, passwordHash, real_name, email, phone, 'active']
    )

    return { success: true, message: 'æ³¨å†ŒæˆåŠŸ', userId: result.insertId }
  } catch (error) {
    console.error('æ³¨å†Œå¤±è´¥:', error)
    return reply.code(500).send({ success: false, message: 'æ³¨å†Œå¤±è´¥' })
  }
})

// ç”¨æˆ·ç™»å½•
fastify.post('/api/auth/login', async (request, reply) => {
  const { username, password } = request.body

  try {
    // æŸ¥è¯¢ç”¨æˆ·
    const [users] = await pool.query(
      'SELECT id, username, password_hash, real_name, email, phone, status FROM users WHERE username = ?',
      [username]
    )

    if (users.length === 0) {
      return reply.code(401).send({ success: false, message: 'Invalid username or password' })
    }

    const user = users[0]

    // è´¦å·çŠ¶æ€æ£€æŸ¥
    if (user.status === 'pending') {
      return reply.code(403).send({ success: false, message: 'è´¦å·å¾…å®¡æ ¸ï¼Œè¯·è”ç³»ç®¡ç†å‘˜' })
    }

    if (user.status !== 'active') {
      return reply.code(403).send({ success: false, message: 'è´¦å·å·²ç¦ç”¨' })
    }

    // éªŒè¯å¯†ç 
    const isValid = await bcrypt.compare(password, user.password_hash)
    if (!isValid) {
      return reply.code(401).send({ success: false, message: 'Invalid username or password' })
    }

    // ç”Ÿæˆ JWT token
    const token = jwt.sign(
      { id: user.id, username: user.username },
      JWT_SECRET,
      { expiresIn: '7d' }
    )

    // æ›´æ–°æœ€åç™»å½•æ—¶é—´
    await pool.query('UPDATE users SET last_login = NOW() WHERE id = ?', [user.id])

    // è¿”å›ç™»å½•ä¿¡æ¯ï¼ˆä¸åŒ…å«å¯†ç ï¼‰
    const { password_hash, ...userInfo } = user

    return {
      success: true,
      message: 'ç™»å½•æˆåŠŸ',
      token,
      user: userInfo
    }
  } catch (error) {
    console.error('ç™»å½•å¤±è´¥:', error)
    return reply.code(500).send({ success: false, message: 'ç™»å½•å¤±è´¥' })
  }
})

// è·å–å½“å‰ç”¨æˆ·çš„æƒé™åˆ—è¡¨
fastify.get('/api/auth/permissions', async (request, reply) => {
  try {
    const token = request.headers.authorization?.replace('Bearer ', '')
    if (!token) {
      return reply.code(401).send({ success: false, message: 'æœªç™»å½•' })
    }

    const decoded = jwt.verify(token, JWT_SECRET)

    // è·å–ç”¨æˆ·çš„è§’è‰²å’Œæƒé™
    const [permissions] = await pool.query(`
      SELECT DISTINCT p.code, p.name, p.resource, p.action, p.module
      FROM permissions p
      INNER JOIN role_permissions rp ON p.id = rp.permission_id
      INNER JOIN user_roles ur ON rp.role_id = ur.role_id
      WHERE ur.user_id = ?
    `, [decoded.id])

    // è·å–ç”¨æˆ·çš„è§’è‰²ä¿¡æ¯
    const [roles] = await pool.query(`
      SELECT r.id, r.name, r.can_view_all_departments
      FROM roles r
      INNER JOIN user_roles ur ON r.id = ur.role_id
      WHERE ur.user_id = ?
    `, [decoded.id])

    // è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    const [user] = await pool.query('SELECT username, department_id FROM users WHERE id = ?', [decoded.id])

    return {
      success: true,
      data: {
        permissions: permissions.map(p => p.code),
        permissionDetails: permissions,
        roles: roles,
        canViewAllDepartments: roles.some(r => r.can_view_all_departments === 1),
        departmentId: user[0]?.department_id
      }
    }
  } catch (error) {
    console.error('è·å–æƒé™å¤±è´¥:', error)
    return reply.code(401).send({ success: false, message: 'è·å–æƒé™å¤±è´¥' })
  }
})

// éªŒè¯ token æ ¡éªŒ
async function verifyToken(request, reply) {
  try {
    const token = request.headers.authorization?.replace('Bearer ', '')
    if (!token) {
      return reply.code(401).send({ success: false, message: 'æœªæä¾›è®¤è¯ä»¤ç‰Œ' })
    }

    const decoded = jwt.verify(token, JWT_SECRET)
    request.user = decoded
  } catch (error) {
    return reply.code(401).send({ success: false, message: 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ' })
  }
}


// ==================== å®¢æœç®¡ç† API ====================

// è·å–å®¢æœäººå‘˜åˆ—è¡¨
fastify.get('/api/customers', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        u.id,
        u.username,
        u.real_name as name,
        u.email,
        u.phone,
        d.name as department,
        u.status,
        e.rating
      FROM users u
      LEFT JOIN employees e ON u.id = e.user_id
      LEFT JOIN departments d ON u.department_id = d.id
      WHERE d.name = 'å®¢æœéƒ¨' OR u.department_id IN (SELECT id FROM departments WHERE name = 'å®¢æœéƒ¨')
      ORDER BY u.created_at DESC
    `)
    return rows
  } catch (error) {
    reply.code(500).send({ error: 'è·å–å®¢æœåˆ—è¡¨å¤±è´¥' })
  }
})

// æ–°å¢å®¢æœäººå‘˜
fastify.post('/api/customers', async (request, reply) => {
  const { name, email, phone, department, status, rating } = request.body

  try {
    // è·å–éƒ¨é—¨ID
    const [deptRows] = await pool.query('SELECT id FROM departments WHERE name = ?', [department])
    const departmentId = deptRows[0]?.id || 6 // é»˜è®¤å®¢æœéƒ¨IDä¸º6

    // ç”Ÿæˆç”¨æˆ·å
    const username = `CS${Date.now()}`
    const passwordHash = '$2b$12$KIXxLQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYqNqYq' // é»˜è®¤å¯†ç : 123456

    // åˆ›å»ºç”¨æˆ·
    const [userResult] = await pool.query(
      'INSERT INTO users (username, password_hash, real_name, email, phone, department_id, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [username, passwordHash, name, email, phone, departmentId, status]
    )

    // åˆ›å»ºå‘˜å·¥ä¿¡æ¯
    const employeeNo = `E${String(userResult.insertId).padStart(3, '0')}`
    await pool.query(
      'INSERT INTO employees (user_id, employee_no, position, hire_date, rating, status) VALUES (?, ?, ?, NOW(), ?, ?)',
      [userResult.insertId, employeeNo, 'å®¢æœä¸“å‘˜', rating, status]
    )

    return { success: true, id: userResult.insertId }
  } catch (error) {
    console.error(error)
    reply.code(500).send({ error: 'æ–°å¢å®¢æœå¤±è´¥' })
  }
})

// æ›´æ–°å®¢æœäººå‘˜
fastify.put('/api/customers/:id', async (request, reply) => {
  const { id } = request.params
  const { name, email, phone, department, status, rating } = request.body

  try {
    // è·å–éƒ¨é—¨ID
    const [deptRows] = await pool.query('SELECT id FROM departments WHERE name = ?', [department])
    const departmentId = deptRows[0]?.id || 6

    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    await pool.query(
      'UPDATE users SET real_name = ?, email = ?, phone = ?, department_id = ?, status = ? WHERE id = ?',
      [name, email, phone, departmentId, status, id]
    )

    // æ›´æ–°å‘˜å·¥ä¿¡æ¯
    await pool.query(
      'UPDATE employees SET rating = ?, status = ? WHERE user_id = ?',
      [rating, status, id]
    )

    return { success: true }
  } catch (error) {
    console.error(error)
    reply.code(500).send({ error: 'æ›´æ–°å®¢æœå¤±è´¥' })
  }
})

// åˆ é™¤å®¢æœäººå‘˜
fastify.delete('/api/customers/:id', async (request, reply) => {
  const { id } = request.params

  try {
    await pool.query('DELETE FROM users WHERE id = ?', [id])
    return { success: true }
  } catch (error) {
    console.error(error)
    reply.code(500).send({ error: 'åˆ é™¤å®¢æœå¤±è´¥' })
  }
})

// è·å–ä¼šè¯åˆ—è¡¨
fastify.get('/api/sessions', async (request, reply) => {
  try {
    // æ¨¡æ‹Ÿä¼šè¯æ•°æ®ï¼ˆå®é™…åº”è¿æ¥ quality_sessions è¡¨ï¼‰
    const sessions = [
      { id: 1, customer: 'å®¢æˆ·A', agent: 'å®¢æœ', startTime: '2024-11-09 09:00', duration: '15åˆ†é’Ÿ', status: 'completed', satisfaction: 5 },
      { id: 2, customer: 'å®¢æˆ·B', agent: 'å®¢æœ', startTime: '2024-11-09 10:30', duration: '8åˆ†é’Ÿ', status: 'completed', satisfaction: 4 },
      { id: 3, customer: 'å®¢æˆ·C', agent: 'å®¢æœ', startTime: '2024-11-09 11:15', duration: 'æ­£åœ¨é€šè¯', status: 'active', satisfaction: null }
    ];
    return sessions;
  } catch (error) {
    reply.code(500).send({ error: 'è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥' });
  }
})

// è·å–è´¨æ£€è®°å½•
fastify.get('/api/quality-inspections', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        qs.id,
        qs.session_id as sessionId,
        u.real_name as agent,
        qs.inspector_name as inspector,
        qs.total_score as score,
        qs.status,
        DATE_FORMAT(qs.created_at, '%Y-%m-%d') as date
      FROM quality_sessions qs
      LEFT JOIN users u ON qs.agent_id = u.id
      ORDER BY qs.created_at DESC
      LIMIT 50
    `);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'è·å–è´¨æ£€åˆ—è¡¨å¤±è´¥' });
  }
});

// æäº¤è´¨æ£€
fastify.post('/api/quality-inspections', async (request, reply) => {
  const { sessionId, scores, comment } = request.body;

  try {
    const totalScore = Math.round(
      scores.attitude * 0.3 +
      scores.professional * 0.3 +
      scores.communication * 0.2 +
      scores.compliance * 0.2
    );

    await pool.query(
      'UPDATE quality_sessions SET status = ?, total_score = ?, inspector_name = ?, comments = ? WHERE id = ?',
      ['completed', totalScore, 'å‰å°äººå‘˜', comment, sessionId]
    );

    return { success: true, score: totalScore };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'æäº¤è´¨æ£€å¤±è´¥' });
  }
})

// ==================== éƒ¨é—¨ç®¡ç† API ====================

// è·å–éƒ¨é—¨åˆ—è¡¨
fastify.get('/api/departments', async (request, reply) => {
  try {
    const { includeDeleted, forManagement } = request.query;
    const { extractUserPermissions } = require('./middleware/checkPermission');

    // è·å–ç”¨æˆ·æƒé™
    const permissions = await extractUserPermissions(request, pool);

    let query = 'SELECT * FROM departments WHERE 1=1';
    const params = [];

    // é»˜è®¤ä¸æ˜¾ç¤ºå·²åˆ é™¤çš„éƒ¨é—¨
    if (includeDeleted !== 'true') {
      query += ' AND status != "deleted"';
    }

    // å¦‚æœæ˜¯ç”¨äºç®¡ç†ç›®çš„ï¼ˆå¦‚é…ç½®è§’è‰²éƒ¨é—¨æƒé™ï¼‰ï¼Œåˆ™è¿”å›æ‰€æœ‰éƒ¨é—¨
    // å¦åˆ™åº”ç”¨æ­£å¸¸çš„æƒé™æ§åˆ¶
    if (forManagement !== 'true') {
      // æƒé™æ§åˆ¶ï¼šéå…¨éƒ¨é—¨æƒé™ç”¨æˆ·åªèƒ½æŸ¥çœ‹è‡ªå·±çš„éƒ¨é—¨
      if (!permissions) {
        // æ²¡æœ‰æƒé™ä¿¡æ¯ï¼ˆæœªç™»å½•æˆ–æ— è§’è‰²ï¼‰ï¼Œçœ‹ä¸åˆ°ä»»ä½•éƒ¨é—¨
        query += ' AND 1=0';
      } else if (!permissions.canViewAllDepartments && !permissions.isAdmin) {
        if (permissions.departmentId) {
          query += ' AND id = ?';
          params.push(permissions.departmentId);
        } else {
          // æ²¡æœ‰éƒ¨é—¨çš„ç”¨æˆ·çœ‹ä¸åˆ°ä»»ä½•éƒ¨é—¨
          query += ' AND 1=0';
        }
      }
    }

    query += ' ORDER BY sort_order, created_at DESC';

    const [rows] = await pool.query(query, params);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'è·å–éƒ¨é—¨åˆ—è¡¨å¤±è´¥' });
  }
});

// åˆ›å»ºéƒ¨é—¨
fastify.post('/api/departments', async (request, reply) => {
  const { name, description, status } = request.body;
  try {
    const [result] = await pool.query(
      'INSERT INTO departments (name, description, status) VALUES (?, ?, ?)',
      [name, description, status]
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'åˆ›å»ºéƒ¨é—¨å¤±è´¥' });
  }
});

// æ›´æ–°éƒ¨é—¨
fastify.put('/api/departments/:id', async (request, reply) => {
  const { id } = request.params;
  const { name, description, status } = request.body;
  try {
    // è·å–åŸéƒ¨é—¨çŠ¶æ€
    const [oldDept] = await pool.query('SELECT status FROM departments WHERE id = ?', [id]);
    const oldStatus = oldDept[0]?.status;

    // æ›´æ–°éƒ¨é—¨ä¿¡æ¯
    await pool.query(
      'UPDATE departments SET name = ?, description = ?, status = ? WHERE id = ?',
      [name, description, status, id]
    );

    // æ ¹æ®çŠ¶æ€å˜æ›´åŒæ­¥æ›´æ–°è¯¥éƒ¨é—¨ä¸‹æ‰€æœ‰å‘˜å·¥çŠ¶æ€
    if (oldStatus && oldStatus !== status) {
      // è·å–è¯¥éƒ¨é—¨ä¸‹çš„æ‰€æœ‰å‘˜å·¥
      const [employees] = await pool.query(`
        SELECT e.id, e.user_id
        FROM employees e
        LEFT JOIN users u ON e.user_id = u.id
        WHERE u.department_id = ?
      `, [id]);

      // æ›´æ–°æ‰€æœ‰å‘˜å·¥çŠ¶æ€
      if (employees.length > 0) {
        const employeeStatus = status === 'active' ? 'active' : 'inactive';
        await pool.query(`
          UPDATE employees
          SET status = ?
          WHERE id IN (${employees.map(() => '?').join(',')})
        `, [employeeStatus, ...employees.map(e => e.id)]);

        console.log(`éƒ¨é—¨ ${id} çŠ¶æ€å˜æ›´ä¸º ${status}ï¼Œå½±å“ ${employees.length} åå‘˜å·¥çŠ¶æ€ä¸º ${employeeStatus}`);
      }
    }

    return {
      success: true,
      affectedEmployees: oldStatus !== status ? (await pool.query(`
        SELECT COUNT(*) as count
        FROM employees e
        LEFT JOIN users u ON e.user_id = u.id
        WHERE u.department_id = ?
      `, [id]))[0][0].count : 0
    };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'æ›´æ–°éƒ¨é—¨å¤±è´¥' });
  }
});

// åˆ é™¤éƒ¨é—¨ï¼ˆè½¯åˆ é™¤ï¼‰
fastify.delete('/api/departments/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    // å°†éƒ¨é—¨çŠ¶æ€è®¾ç½®ä¸º deleted
    await pool.query('UPDATE departments SET status = ? WHERE id = ?', ['deleted', id]);

    // åŒæ—¶å°†è¯¥éƒ¨é—¨ä¸‹çš„æ‰€æœ‰å‘˜å·¥çŠ¶æ€è®¾ç½®ä¸º deleted
    await pool.query(`
      UPDATE employees e
      LEFT JOIN users u ON e.user_id = u.id
      SET e.status = 'deleted'
      WHERE u.department_id = ?
    `, [id]);

    return { success: true, message: 'éƒ¨é—¨åˆ é™¤æˆåŠŸ' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'åˆ é™¤éƒ¨é—¨å¤±è´¥' });
  }
});

// æ¢å¤éƒ¨é—¨
fastify.post('/api/departments/:id/restore', async (request, reply) => {
  const { id } = request.params;
  try {
    // æ¢å¤éƒ¨é—¨çŠ¶æ€ä¸º active
    await pool.query('UPDATE departments SET status = ? WHERE id = ?', ['active', id]);

    // åŒæ—¶æ¢å¤è¯¥éƒ¨é—¨ä¸‹çš„æ‰€æœ‰å‘˜å·¥çŠ¶æ€ä¸º active
    await pool.query(`
      UPDATE employees e
      LEFT JOIN users u ON e.user_id = u.id
      SET e.status = 'active'
      WHERE u.department_id = ? AND e.status = 'deleted'
    `, [id]);

    return { success: true, message: 'éƒ¨é—¨æ¢å¤æˆåŠŸ' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'æ¢å¤éƒ¨é—¨å¤±è´¥' });
  }
});

// ==================== èŒä½ç®¡ç† API ====================
// èŒä½ç®¡ç†è·¯ç”±å·²ç§»è‡³ server/routes/positions.js

// ==================== å‘˜å·¥ç®¡ç† API ====================

// è·å–å‘˜å·¥åˆ—è¡¨
fastify.get('/api/employees', async (request, reply) => {
  try {
    const { includeDeleted } = request.query;
    const { extractUserPermissions, applyDepartmentFilter } = require('./middleware/checkPermission');

    // è·å–ç”¨æˆ·æƒé™
    const permissions = await extractUserPermissions(request, pool);

    let query = `
      SELECT
        e.id,
        e.employee_no,
        e.position,
        e.hire_date,
        e.rating,
        e.status,
        e.emergency_contact,
        e.emergency_phone,
        e.address,
        e.education,
        e.skills,
        e.remark,
        u.id as user_id,
        u.username,
        u.real_name,
        u.email,
        u.phone,
        u.avatar,
        u.department_id,
        d.name as department_name
      FROM employees e
      LEFT JOIN users u ON e.user_id = u.id
      LEFT JOIN departments d ON u.department_id = d.id
      WHERE 1=1
    `;

    const params = [];

    // é»˜è®¤ä¸æ˜¾ç¤ºå·²åˆ é™¤çš„å‘˜å·¥
    if (includeDeleted !== 'true') {
      query += ' AND e.status != "deleted"';
    }

    // åº”ç”¨éƒ¨é—¨æƒé™è¿‡æ»¤
    const filtered = applyDepartmentFilter(permissions, query, params, 'u.department_id');
    query = filtered.query;
    const finalParams = filtered.params;

    query += ' ORDER BY e.created_at DESC';

    const [rows] = await pool.query(query, finalParams);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'è·å–å‘˜å·¥åˆ—è¡¨å¤±è´¥' });
  }
});

// åˆ›å»ºå‘˜å·¥
fastify.post('/api/employees', async (request, reply) => {
  const { employee_no, real_name, email, phone, department_id, position, hire_date, rating, status } = request.body;
  try {
    const passwordHash = '$2b$12$KIXxLQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYqNqYq'; // é»˜è®¤å¯†ç : 123456

    // ç¡®ä¿å‘˜å·¥ç¼–å·ä½œä¸ºç”¨æˆ·åä½¿ï¿½?
    const username = employee_no;

    // åˆ›å»ºç”¨æˆ·
    const [userResult] = await pool.query(
      'INSERT INTO users (username, password_hash, real_name, email, phone, department_id, status) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [username, passwordHash, real_name, email || null, phone || null, department_id || null, 'active']
    );

    // åˆ›å»ºå‘˜å·¥ä¿¡æ¯
    await pool.query(
      'INSERT INTO employees (user_id, employee_no, position, hire_date, rating, status) VALUES (?, ?, ?, ?, ?, ?)',
      [userResult.insertId, employee_no, position || null, hire_date || new Date(), rating || 3, status]
    );

    return { success: true, id: userResult.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'åˆ›å»ºå‘˜å·¥å¤±è´¥' });
  }
});

// æ›´æ–°å‘˜å·¥
fastify.put('/api/employees/:id', async (request, reply) => {
  const { id } = request.params;
  const {
    employee_no, real_name, email, phone, department_id, position,
    hire_date, rating, status, avatar, emergency_contact, emergency_phone,
    address, education, skills, remark
  } = request.body;

  try {
    // è·å–å‘˜å·¥çš„user_id
    const [empRows] = await pool.query('SELECT user_id FROM employees WHERE id = ?', [id]);
    if (empRows.length === 0) {
      return reply.code(404).send({ error: 'å‘˜å·¥ä¸å­˜åœ¨' });
    }
    const userId = empRows[0].user_id;

    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    await pool.query(
      'UPDATE users SET real_name = ?, email = ?, phone = ?, department_id = ?, avatar = ? WHERE id = ?',
      [real_name, email || null, phone || null, department_id || null, avatar || null, userId]
    );

    // æ›´æ–°å‘˜å·¥ä¿¡æ¯
    await pool.query(
      `UPDATE employees SET
        employee_no = ?,
        position = ?,
        hire_date = ?,
        rating = ?,
        status = ?,
        emergency_contact = ?,
        emergency_phone = ?,
        address = ?,
        education = ?,
        skills = ?,
        remark = ?
      WHERE id = ?`,
      [
        employee_no,
        position || null,
        hire_date || null,
        rating || 3,
        status,
        emergency_contact || null,
        emergency_phone || null,
        address || null,
        education || null,
        skills || null,
        remark || null,
        id
      ]
    );

    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'æ›´æ–°å‘˜å·¥å¤±è´¥' });
  }
});

// åˆ é™¤å‘˜å·¥ï¼ˆè½¯åˆ é™¤ï¼‰
fastify.delete('/api/employees/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    // å°†å‘˜å·¥çŠ¶æ€è®¾ç½®ä¸º deleted
    await pool.query('UPDATE employees SET status = ? WHERE id = ?', ['deleted', id]);
    return { success: true, message: 'å‘˜å·¥åˆ é™¤æˆåŠŸ' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'åˆ é™¤å‘˜å·¥å¤±è´¥' });
  }
});

// æ¢å¤å‘˜å·¥
fastify.post('/api/employees/:id/restore', async (request, reply) => {
  const { id } = request.params;
  try {
    // æ¢å¤å‘˜å·¥çŠ¶æ€ä¸º active
    await pool.query('UPDATE employees SET status = ? WHERE id = ?', ['active', id]);
    return { success: true, message: 'å‘˜å·¥æ¢å¤æˆåŠŸ' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'æ¢å¤å‘˜å·¥å¤±è´¥' });
  }
});

// ==================== å‘˜å·¥å®¡æ‰¹ API ====================

// è·å–å¾…å®¡æ‰¹çš„ç”¨æˆ·åˆ—è¡¨
fastify.get('/api/users-pending', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        u.id,
        u.username,
        u.real_name,
        u.email,
        u.phone,
        u.department_id,
        u.created_at,
        d.name as department_name
      FROM users u
      LEFT JOIN departments d ON u.department_id = d.id
      WHERE u.status = 'pending'
      ORDER BY u.created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch pending users' });
  }
});

// æ‰¹å‡†ç”¨æˆ·
fastify.post('/api/users/:id/approve', async (request, reply) => {
  const { id } = request.params;
  const { note } = request.body;

  try {
    await pool.query(
      'UPDATE users SET status = ?, updated_at = NOW() WHERE id = ?',
      ['active', id]
    );

    // è®°å½•å®¡æ‰¹æ—¥å¿—
    // await pool.query(
    //   'INSERT INTO approval_logs (user_id, action, note, created_at) VALUES (?, ?, ?, NOW())',
    //   [id, 'approve', note]
    // );

    return { success: true, message: 'Approved successfully' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Approval failed' });
  }
});

// æ‹’ç»ç”¨æˆ·
fastify.post('/api/users/:id/reject', async (request, reply) => {
  const { id } = request.params;
  const { note } = request.body;

  try {
    await pool.query(
      'UPDATE users SET status = ?, updated_at = NOW() WHERE id = ?',
      ['inactive', id]
    );

    // è®°å½•å®¡æ‰¹æ—¥å¿—
    // await pool.query(
    //   'INSERT INTO approval_logs (user_id, action, note, created_at) VALUES (?, ?, ?, NOW())',
    //   [id, 'reject', note]
    // );

    return { success: true, message: 'Rejected successfully' };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Rejection failed' });
  }
});

// ==================== å‘˜å·¥å˜åŠ¨è®°å½• API ====================

// è·å–å‘˜å·¥å˜åŠ¨è®°å½•
fastify.get('/api/employee-changes', async (request, reply) => {
  const { type } = request.query;
  try {
    let query = `
      SELECT
        ec.*,
        u.real_name,
        e.employee_no,
        d1.name as old_department_name,
        d2.name as new_department_name
      FROM employee_changes ec
      LEFT JOIN users u ON ec.user_id = u.id
      LEFT JOIN employees e ON ec.employee_id = e.id
      LEFT JOIN departments d1 ON ec.old_department_id = d1.id
      LEFT JOIN departments d2 ON ec.new_department_id = d2.id
    `;

    const params = [];
    if (type && type !== 'all') {
      query += ' WHERE ec.change_type = ?';
      params.push(type);
    }

    query += ' ORDER BY ec.change_date DESC, ec.created_at DESC LIMIT 100';

    const [rows] = await pool.query(query, params);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch employee changes' });
  }
});

// è·å–å‘˜å·¥çš„å˜åŠ¨å†ï¿½?
fastify.get('/api/employee-changes/:employeeId', async (request, reply) => {
  const { employeeId } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT
        ec.*,
        d1.name as old_department_name,
        d2.name as new_department_name
      FROM employee_changes ec
      LEFT JOIN departments d1 ON ec.old_department_id = d1.id
      LEFT JOIN departments d2 ON ec.new_department_id = d2.id
      WHERE ec.employee_id = ?
      ORDER BY ec.change_date DESC, ec.created_at DESC
    `, [employeeId]);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch employee change history' });
  }
});

// åˆ›å»ºå‘˜å·¥å˜åŠ¨è®°å½•
fastify.post('/api/employee-changes/create', async (request, reply) => {
  const {
    employee_id,
    user_id,
    change_type,
    change_date,
    old_department_id,
    new_department_id,
    old_position,
    new_position,
    reason
  } = request.body;

  try {
    const [result] = await pool.query(
      `INSERT INTO employee_changes
      (employee_id, user_id, change_type, change_date, old_department_id, new_department_id, old_position, new_position, reason)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [employee_id, user_id, change_type, change_date, old_department_id, new_department_id, old_position, new_position, reason]
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to create employee change' });
  }
});

// ä¿æŒåœ¨æ–‡ä»¶æœ«å°¾è°ƒï¿½?start()

// ==================== çŸ¥è¯†åº“ç®¡ï¿½?API ====================

// è·å–çŸ¥è¯†åº“åˆ†ç±»åˆ—ï¿½?
fastify.get('/api/knowledge/categories', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT * FROM knowledge_categories
      WHERE is_active = 1 AND deleted_at IS NULL
      ORDER BY sort_order, created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch knowledge categories' });
  }
});

// åˆ›å»ºçŸ¥è¯†åº“åˆ†ï¿½?
fastify.post('/api/knowledge/categories', async (request, reply) => {
  const { name, description, icon } = request.body;
  try {
    console.log('Creating knowledge category:', { name, description, icon });

    if (!name) {
      return reply.code(400).send({ error: 'Category name is required' });
    }

    const [result] = await pool.query(
      'INSERT INTO knowledge_categories (name, description, icon) VALUES (?, ?, ?)',
      [name, description || null, icon || 'ğŸ“']
    );

    console.log('Created knowledge category with ID:', result.insertId);
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error('Failed to create knowledge category:', error);
    reply.code(500).send({ error: 'Failed to create knowledge category: ' + error.message });
  }
});

// æ›´æ–°çŸ¥è¯†åº“åˆ†ï¿½?
fastify.put('/api/knowledge/categories/:id', async (request, reply) => {
  const { id } = request.params;
  const { name, description, icon, is_hidden, is_published } = request.body;
  try {
    // æ„å»ºæ›´æ–°è¯­å¥
    const updates = [];
    const values = [];

    if (name !== undefined) {
      updates.push('name = ?');
      values.push(name);
    }
    if (description !== undefined) {
      updates.push('description = ?');
      values.push(description || null);
    }
    if (icon !== undefined) {
      updates.push('icon = ?');
      values.push(icon || 'ğŸ“');
    }
    if (is_hidden !== undefined) {
      updates.push('is_hidden = ?');
      values.push(is_hidden ? 1 : 0);
    }
    if (is_published !== undefined) {
      updates.push('is_published = ?');
      values.push(is_published ? 1 : 0);
    }

    if (updates.length === 0) {
      return reply.code(400).send({ error: 'No updates provided' });
    }

    values.push(id);
    await pool.query(
      `UPDATE knowledge_categories SET ${updates.join(', ')} WHERE id = ?`,
      values
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to update knowledge category' });
  }
});

// åˆ é™¤çŸ¥è¯†åº“åˆ†ï¿½?
fastify.delete('/api/knowledge/categories/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    // å°†å…³è”çš„æ–‡ç« ï¿½?category_id è®¾ç½®ï¿½?NULL
    await pool.query(
      'UPDATE knowledge_articles SET category_id = NULL WHERE category_id = ?',
      [id]
    );

    // åˆ é™¤åˆ†ç±»
    await pool.query('DELETE FROM knowledge_categories WHERE id = ?', [id]);

    return { success: true };
  } catch (error) {
    console.error('Failed to delete knowledge category:', error);
    reply.code(500).send({ error: 'Failed to delete knowledge category' });
  }
});

// åˆ‡æ¢åˆ†ç±»æ˜¾ç¤ºéšè—çŠ¶æ€ï¼ˆåŒæ—¶æ›´æ–°è¯¥åˆ†ç±»ä¸‹æ‰€æœ‰æ–‡æ¡£çŠ¶æ€ï¼‰
fastify.post('/api/knowledge/categories/:id/toggle-visibility', async (request, reply) => {
  const { id } = request.params;
  const { is_hidden } = request.body;

  try {
    console.log(`åˆ‡æ¢åˆ†ç±» ${id} çš„å¯è§æ€§ï¼Œis_hidden: ${is_hidden}`);

    // å¼€å§‹äº‹ï¿½?
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      // 1. æ›´æ–°åˆ†ç±»çš„éšè—çŠ¶ï¿½?
      await connection.query(
        'UPDATE knowledge_categories SET is_hidden = ? WHERE id = ?',
        [is_hidden ? 1 : 0, id]
      );

      // 2. æ ¹æ®éšè—çŠ¶æ€æ›´æ–°è¯¥åˆ†ç±»ä¸‹æ‰€æœ‰æ–‡æ¡£çŠ¶æ€ä¸º deleted
      // æ˜¾ç¤º(is_hidden=0) -> æ–‡æ¡£çŠ¶æ€æ”¹ï¿½?published
      // éšè—(is_hidden=1) -> æ–‡æ¡£çŠ¶æ€æ”¹ï¿½?archived
      const newArticleStatus = is_hidden ? 'archived' : 'published';
      const [result] = await connection.query(
        'UPDATE knowledge_articles SET status = ? WHERE category_id = ?',
        [newArticleStatus, id]
      );

      // æäº¤äº‹åŠ¡
      await connection.commit();
      connection.release();

      console.log('Updated category and number of articles: ' + result.affectedRows);

      return {
        success: true,
        affectedArticles: result.affectedRows,
        message: is_hidden
          ? `å·²éšè—åˆ†ç±»ï¼Œ${result.affectedRows} ç¯‡æ–‡æ¡£å·²å½’æ¡£`
          : `å·²æ˜¾ç¤ºåˆ†ç±»ï¼Œ${result.affectedRows} ç¯‡æ–‡æ¡£å·²å‘å¸ƒ`
      };
    } catch (error) {
      // å›æ»šäº‹åŠ¡
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('åˆ‡æ¢åˆ†ç±»å¯è§æ€§å¤±ï¿½?', error);
    reply.code(500).send({ error: 'Failed to toggle category visibility: ' + error.message });
  }
});

// è·å–çŸ¥è¯†æ–‡ç« åˆ—è¡¨
fastify.get('/api/knowledge/articles', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        ka.*,
        kc.name as category_name,
        u.real_name as author_name
      FROM knowledge_articles ka
      LEFT JOIN knowledge_categories kc ON ka.category_id = kc.id
      LEFT JOIN users u ON ka.created_by = u.id
      WHERE ka.status != 'deleted'
      ORDER BY ka.created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error('Failed to fetch knowledge articles:', error);
    reply.code(500).send({ error: 'Failed to fetch knowledge articles' });
  }
});

// åˆ›å»ºçŸ¥è¯†æ–‡ç« 
fastify.post('/api/knowledge/articles', async (request, reply) => {
  const { title, category_id, summary, content, type, status, icon, attachments } = request.body;
  try {
    const attachmentsJson = attachments && attachments.length > 0 ? JSON.stringify(attachments) : null;

    const [result] = await pool.query(
      `INSERT INTO knowledge_articles
      (title, category_id, summary, content, attachments, type, status, icon, created_by)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [title, category_id || null, summary || null, content, attachmentsJson, type, status, icon || 'ğŸ“„', request.user?.id || null]
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to create knowledge article' });
  }
});

// æ›´æ–°çŸ¥è¯†æ–‡ç« 
fastify.put('/api/knowledge/articles/:id', async (request, reply) => {
  const { id } = request.params;
  const { title, category_id, summary, content, type, status, icon, attachments } = request.body;
  try {
    console.log('========================================');
    console.log('Updating knowledge article:');
    console.log('ID:', id);
    console.log('Title:', title, '(type:', typeof title, ')');
    console.log('Content:', content ? `${content.substring(0, 50)}...` : 'NULL');
    console.log('Type:', type);
    console.log('Status:', status);
    console.log('Category ID:', category_id);
    console.log('Attachments:', attachments?.length, '(type:', typeof attachments, ')');
    console.log('========================================');

    // éªŒè¯å¿…è¦å­—æ®µ
    if (!title || title.trim() === '') {
      console.error('Ã— title å­—æ®µä¸ºç©º');
      return reply.code(400).send({ error: 'Title is required' });
    }

    if (!content || content.trim() === '') {
      console.error('Ã— content å­—æ®µä¸ºç©º');
      return reply.code(400).send({ error: 'Content is required' });
    }

    // å¤„ç†é™„ä»¶æ•°æ®
    let attachmentsJson = null;
    if (attachments) {
      if (Array.isArray(attachments)) {
        attachmentsJson = attachments.length > 0 ? JSON.stringify(attachments) : null;
      } else if (typeof attachments === 'string') {
        attachmentsJson = attachments;
      } else {
        console.warn('attachments ç±»å‹ä¸æ­£ï¿½?', typeof attachments, attachments);
        attachmentsJson = JSON.stringify(attachments);
      }
    }

    console.log('å‡†å¤‡æ›´æ–°æ•°æ®ï¼ŒattachmentsJson:', attachmentsJson ? 'æœ‰æ•°æ®' : 'NULL');

    const result = await pool.query(
      `UPDATE knowledge_articles SET
        title = ?,
        category_id = ?,
        summary = ?,
        content = ?,
        attachments = ?,
        type = ?,
        status = ?,
        icon = ?,
        updated_by = ?
      WHERE id = ?`,
      [title, category_id || null, summary || null, content, attachmentsJson, type, status, icon || 'ğŸ“„', request.user?.id || null, id]
    );

    console.log('æ–‡æ¡£æ›´æ–°æˆåŠŸ:', id, 'å½±å“è¡Œæ•°:', result[0].affectedRows);
    return { success: true };
  } catch (error) {
    console.error('Failed to update knowledge article:', error);
    console.error('Failed to update knowledge article:', error.message);
    console.error('SQLçŠ¶ï¿½?', error.sqlState);
    console.error('SQLä¿¡æ¯:', error.sqlMessage);
    reply.code(500).send({ error: 'Failed to update knowledge article: ' + error.message });
  }
});

// åˆ é™¤çŸ¥è¯†æ–‡ç« 
fastify.delete('/api/knowledge/articles/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    await pool.query('DELETE FROM knowledge_articles WHERE id = ?', [id]);
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to delete knowledge article' });
  }
});

// ==================== å›æ”¶ï¿½?API ====================

// è½¯åˆ é™¤åˆ†ï¿½?
fastify.post('/api/knowledge/categories/:id/soft-delete', async (request, reply) => {
  const { id } = request.params;
  const userId = request.user?.id || null;

  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      // 1. æ£€æŸ¥åˆ†ç±»æ˜¯å¦å­˜ï¿½?
      const [categories] = await connection.query(
        'SELECT id FROM knowledge_categories WHERE id = ?',
        [id]
      );

      if (categories.length === 0) {
        await connection.rollback();
        connection.release();
        return reply.code(404).send({ error: 'Category not found' });
      }

      // 2. æ›´æ–°åˆ†ç±»çš„éšè—çŠ¶ï¿½?
      await connection.query(
        `UPDATE knowledge_categories
         SET deleted_at = NOW(), deleted_by = ?
         WHERE id = ?`,
        [userId, id]
      );

      // 3. æ ¹æ®éšè—çŠ¶æ€æ›´æ–°è¯¥åˆ†ç±»ä¸‹æ‰€æœ‰æ–‡æ¡£çŠ¶æ€ä¸º deleted
      const [result] = await connection.query(
        `UPDATE knowledge_articles
         SET status = 'deleted', deleted_at = NOW(), deleted_by = ?
         WHERE category_id = ? AND status != 'deleted'`,
        [userId, id]
      );

      await connection.commit();
      connection.release();

      return {
        success: true,
        message: 'Category soft deleted',
        deletedArticles: result.affectedRows
      };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('è½¯åˆ é™¤åˆ†ç±»å¤±ï¿½?', error);
    reply.code(500).send({ error: 'Failed to soft delete category: ' + error.message });
  }
});

// è½¯åˆ é™¤æ–‡ï¿½?
fastify.post('/api/knowledge/articles/:id/soft-delete', async (request, reply) => {
  const { id } = request.params;
  const userId = request.user?.id || null;

  try {
    // æ£€æŸ¥æ–‡æ¡£æ˜¯å¦å­˜ï¿½?
    const [articles] = await pool.query(
      'SELECT id FROM knowledge_articles WHERE id = ?',
      [id]
    );

    if (articles.length === 0) {
      return reply.code(404).send({ error: 'Article not found' });
    }

    await pool.query(
      `UPDATE knowledge_articles
       SET status = 'deleted', deleted_at = NOW(), deleted_by = ?
       WHERE id = ?`,
      [userId, id]
    );

    return {
      success: true,
      message: 'Article soft deleted'
    };
  } catch (error) {
    console.error('è½¯åˆ é™¤æ–‡æ¡£å¤±ï¿½?', error);
    reply.code(500).send({ error: 'Failed to soft delete article: ' + error.message });
  }
});

// è·å–å›æ”¶ç«™ä¸­çš„åˆ†ï¿½?
fastify.get('/api/knowledge/recycle-bin/categories', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        kc.*,
        u.real_name as deleted_by_name,
        (SELECT COUNT(*) FROM knowledge_articles WHERE category_id = kc.id AND status = 'deleted') as article_count
      FROM knowledge_categories kc
      LEFT JOIN users u ON kc.deleted_by = u.id
      WHERE kc.deleted_at IS NOT NULL
      ORDER BY kc.deleted_at DESC
    `);

    return {
      success: true,
      data: rows
    };
  } catch (error) {
    console.error('è·å–å›æ”¶ç«™åˆ†ç±»å¤±ï¿½?', error);
    reply.code(500).send({ error: 'Failed to fetch recycle bin categories: ' + error.message });
  }
});

// è·å–å›æ”¶ç«™ä¸­çš„æ–‡ï¿½?
fastify.get('/api/knowledge/recycle-bin/articles', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        ka.*,
        kc.name as category_name,
        u1.real_name as author_name,
        u2.real_name as deleted_by_name
      FROM knowledge_articles ka
      LEFT JOIN knowledge_categories kc ON ka.category_id = kc.id
      LEFT JOIN users u1 ON ka.created_by = u1.id
      LEFT JOIN users u2 ON ka.deleted_by = u2.id
      WHERE ka.status = 'deleted'
      ORDER BY ka.deleted_at DESC
    `);

    return {
      success: true,
      data: rows
    };
  } catch (error) {
    console.error('è·å–å›æ”¶ç«™æ–‡æ¡£å¤±ï¿½?', error);
    reply.code(500).send({ error: 'Failed to fetch recycle bin articles: ' + error.message });
  }
});

// æ¢å¤åˆ†ç±»
fastify.post('/api/knowledge/recycle-bin/categories/:id/restore', async (request, reply) => {
  const { id } = request.params;
  const { restoreArticles } = request.body;

  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      // 1. æ¢å¤åˆ†ç±»
      await connection.query(
        `UPDATE knowledge_categories
         SET deleted_at = NULL, deleted_by = NULL
         WHERE id = ?`,
        [id]
      );

      let restoredArticles = 0;
      // 2. å¯é€‰ï¼šæ¢å¤è¯¥åˆ†ç±»ä¸‹çš„æ–‡ï¿½?
      if (restoreArticles) {
        const [result] = await connection.query(
          `UPDATE knowledge_articles
           SET status = 'published', deleted_at = NULL, deleted_by = NULL
           WHERE category_id = ? AND status = 'deleted'`,
          [id]
        );
        restoredArticles = result.affectedRows;
      }

      await connection.commit();
      connection.release();

      return {
        success: true,
        message: 'Category restored',
        restoredArticles
      };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('æ¢å¤åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to restore category: ' + error.message });
  }
});

// æ¢å¤æ–‡æ¡£
fastify.post('/api/knowledge/recycle-bin/articles/:id/restore', async (request, reply) => {
  const { id } = request.params;

  try {
    await pool.query(
      `UPDATE knowledge_articles
       SET status = 'published', deleted_at = NULL, deleted_by = NULL
       WHERE id = ?`,
      [id]
    );

    return {
      success: true,
      message: 'Article restored'
    };
  } catch (error) {
    console.error('æ¢å¤æ–‡æ¡£å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to restore article: ' + error.message });
  }
});

// æ°¸ä¹…åˆ é™¤åˆ†ç±»
fastify.delete('/api/knowledge/recycle-bin/categories/:id/permanent', async (request, reply) => {
  const { id } = request.params;

  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      // 1. æ°¸ä¹…åˆ é™¤è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰æ–‡ï¿½?
      const [result] = await connection.query(
        'DELETE FROM knowledge_articles WHERE category_id = ? AND status = \'deleted\'',
        [id]
      );

      // 2. æ°¸ä¹…åˆ é™¤åˆ†ç±»
      await connection.query(
        'DELETE FROM knowledge_categories WHERE id = ?',
        [id]
      );

      await connection.commit();
      connection.release();

      return {
        success: true,
        message: 'Category permanently deleted',
        deletedArticles: result.affectedRows
      };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('æ°¸ä¹…åˆ é™¤åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to permanently delete category: ' + error.message });
  }
});

// æ°¸ä¹…åˆ é™¤æ–‡æ¡£
fastify.delete('/api/knowledge/recycle-bin/articles/:id/permanent', async (request, reply) => {
  const { id } = request.params;

  try {
    await pool.query(
      'DELETE FROM knowledge_articles WHERE id = ? AND status = \'deleted\'',
      [id]
    );

    return {
      success: true,
      message: 'Article permanently deleted'
    };
  } catch (error) {
    console.error('æ°¸ä¹…åˆ é™¤æ–‡æ¡£å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to permanently delete article: ' + error.message });
  }
});

// æ¸…ç©ºå›æ”¶ç«™
fastify.post('/api/knowledge/recycle-bin/empty', async (request, reply) => {
  const { type } = request.body; // 'all', 'categories', 'articles'

  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      let deletedCategories = 0;
      let deletedArticles = 0;

      if (type === 'all' || type === 'articles') {
        // åˆ é™¤æ‰€æœ‰å·²åˆ é™¤çš„æ–‡æ¡£
        const [articleResult] = await connection.query(
          'DELETE FROM knowledge_articles WHERE status = \'deleted\''
        );
        deletedArticles = articleResult.affectedRows;
      }

      if (type === 'all' || type === 'categories') {
        // åˆ é™¤æ‰€æœ‰å·²åˆ é™¤çš„åˆ†ç±»
        const [categoryResult] = await connection.query(
          'DELETE FROM knowledge_categories WHERE deleted_at IS NOT NULL'
        );
        deletedCategories = categoryResult.affectedRows;
      }

      await connection.commit();
      connection.release();

      return {
        success: true,
        message: 'Recycle bin emptied',
        deletedCategories,
        deletedArticles
      };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('æ¸…ç©ºå›æ”¶ç«™å¤±è´¥', error);
    reply.code(500).send({ error: 'Failed to empty recycle bin: ' + error.message });
  }
});

// ==================== è€ƒæ ¸ç³»ç»Ÿ API ====================

// è·å–è€ƒè¯•åˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µã€ç­›é€‰ã€æœç´¢ï¼‰
fastify.get('/api/exams', async (request, reply) => {
  const {
    page = 1,
    pageSize = 10,
    category,
    difficulty,
    status,
    title
  } = request.query

  console.log('ğŸ“‹ è·å–è¯•å·åˆ—è¡¨è¯·æ±‚:', { page, pageSize, category, difficulty, status, title })

  try {
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    let query = `
      SELECT
        e.id,
        e.title,
        e.category,
        e.difficulty,
        e.duration,
        e.total_score,
        e.pass_score,
        e.question_count,
        e.status,
        e.created_at
      FROM exams e
      WHERE 1=1
    `
    const params = []

    // åˆ†ç±»ç­›é€‰
    if (category) {
      query += ' AND e.category = ?'
      params.push(category)
    }

    // éš¾åº¦ç­›é€‰
    if (difficulty) {
      query += ' AND e.difficulty = ?'
      params.push(difficulty)
    }

    // çŠ¶æ€ç­›é€‰
    if (status) {
      query += ' AND e.status = ?'
      params.push(status)
    }

    // æ ‡é¢˜æ¨¡ç³Šæœç´¢
    if (title) {
      query += ' AND e.title LIKE ?'
      params.push(`%${title}%`)
    }

    // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—
    query += ' ORDER BY e.created_at DESC'

    // è®¡ç®—æ€»æ•°
    const countQuery = query.replace(
      /SELECT[\s\S]*?FROM/,
      'SELECT COUNT(*) as total FROM'
    ).replace(/ORDER BY.*$/, '')

    const [countResult] = await pool.query(countQuery, params)
    const total = countResult[0].total

    // åˆ†é¡µ
    const offset = (parseInt(page) - 1) * parseInt(pageSize)
    query += ' LIMIT ? OFFSET ?'
    params.push(parseInt(pageSize), offset)

    console.log('ğŸ“‹ æ‰§è¡ŒæŸ¥è¯¢')
    console.log('  SQL:', query.replace(/\s+/g, ' '))
    console.log('  å‚æ•°:', params)

    const [rows] = await pool.query(query, params)
    console.log('ğŸ“‹ æŸ¥è¯¢ç»“æœ:', rows.length, 'æ¡')

    return {
      success: true,
      data: rows,
      pagination: {
        page: parseInt(page),
        pageSize: parseInt(pageSize),
        total,
        totalPages: Math.ceil(total / parseInt(pageSize))
      }
    }
  } catch (error) {
    console.error('âŒ è·å–è¯•å·åˆ—è¡¨å¤±è´¥:', error)
    return reply.code(500).send({
      success: false,
      message: 'è·å–è¯•å·åˆ—è¡¨å¤±è´¥',
      error: error.message
    })
  }
});

// åˆ›å»ºè€ƒè¯•
fastify.post('/api/exams', async (request, reply) => {
  const { title, description, category, difficulty, duration, total_score, pass_score, status } = request.body;
  try {
    const [result] = await pool.query(
      `INSERT INTO exams
      (title, description, category, difficulty, duration, total_score, pass_score, status, created_by)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [title, description || null, category || null, difficulty, duration, total_score, pass_score, status, request.user?.id || null]
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to create exam' });
  }
});

// æ›´æ–°è€ƒè¯•
fastify.put('/api/exams/:id', async (request, reply) => {
  const { id } = request.params;
  const { title, description, category, difficulty, duration, total_score, pass_score, status } = request.body;
  try {
    await pool.query(
      `UPDATE exams SET
        title = ?,
        description = ?,
        category = ?,
        difficulty = ?,
        duration = ?,
        total_score = ?,
        pass_score = ?,
        status = ?
      WHERE id = ?`,
      [title, description || null, category || null, difficulty, duration, total_score, pass_score, status, id]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to update exam' });
  }
});

// åˆ é™¤è€ƒè¯•
fastify.delete('/api/exams/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    await pool.query('DELETE FROM exams WHERE id = ?', [id]);
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to delete exam' });
  }
});

// è·å–è€ƒè¯•çš„é¢˜ç›®åˆ—ï¿½?
fastify.get('/api/exams/:id/questions', async (request, reply) => {
  const { id } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT * FROM questions
      WHERE exam_id = ?
      ORDER BY order_num, id
    `, [id]);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch exam questions' });
  }
});

// æ·»åŠ é¢˜ç›®
fastify.post('/api/exams/:id/questions', async (request, reply) => {
  const { id } = request.params;
  const { type, content, options, correct_answer, score, explanation } = request.body;
  try {
    const [result] = await pool.query(
      `INSERT INTO questions
      (exam_id, type, content, options, correct_answer, score, explanation)
      VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [id, type, content, options || null, correct_answer, score, explanation || null]
    );

    // æ›´æ–°è€ƒè¯•çš„é¢˜ç›®æ•°ï¿½?
    await pool.query('UPDATE exams SET question_count = question_count + 1 WHERE id = ?', [id]);

    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to create question' });
  }
});

// åˆ é™¤é¢˜ç›®
fastify.delete('/api/questions/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    // è·å–é¢˜ç›®æ‰€å±è€ƒè¯•
    const [questions] = await pool.query('SELECT exam_id FROM questions WHERE id = ?', [id]);
    if (questions.length > 0) {
      const examId = questions[0].exam_id;
      await pool.query('DELETE FROM questions WHERE id = ?', [id]);
      // æ›´æ–°è€ƒè¯•çš„é¢˜ç›®æ•°ï¿½?
      await pool.query('UPDATE exams SET question_count = question_count - 1 WHERE id = ?', [examId]);
    }
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to delete question' });
  }
});

// é‡æ–°æ’åºé¢˜ç›®
fastify.put('/api/exams/:id/questions/reorder', async (request, reply) => {
  const { id } = request.params;
  const { questions } = request.body;

  try {
    // é‡æ–°æ’åºæ‰€æœ‰é¢˜ï¿½?
    for (const question of questions) {
      await pool.query(
        'UPDATE questions SET order_num = ? WHERE id = ?',
        [question.order_num, question.id]
      );
    }
    return { success: true };
  } catch (error) {
    console.error('Failed to reorder questions:', error);
    reply.code(500).send({ error: 'Failed to reorder questions' });
  }
});

// è·å–é¢˜åº“
fastify.get('/api/question-bank', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT * FROM questions
      ORDER BY created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error('Failed to fetch question bank:', error);
    reply.code(500).send({ error: 'Failed to fetch question bank' });
  }
});

// æ›´æ–°é¢˜ç›®
fastify.put('/api/questions/:id', async (request, reply) => {
  const { id } = request.params;
  const { type, content, options, correct_answer, score, explanation } = request.body;

  try {
    await pool.query(
      `UPDATE questions
       SET type = ?, content = ?, options = ?, correct_answer = ?, score = ?, explanation = ?
       WHERE id = ?`,
      [type, content, options, correct_answer, score, explanation, id]
    );
    return { success: true };
  } catch (error) {
    console.error('æ›´æ–°é¢˜ç›®å¤±è´¥:', error);
    reply.code(500).send({ error: 'æ›´æ–°é¢˜ç›®å¤±è´¥' });
  }
});

// ==================== è€ƒè¯•åˆ†ç±»ç®¡ç† API ====================

// è·å–è€ƒè¯•åˆ†ç±»åˆ—è¡¨
fastify.get('/api/exam-categories', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        ec.*,
        COUNT(e.id) as exam_count
      FROM exam_categories ec
      LEFT JOIN exams e ON ec.id = e.category_id
      GROUP BY ec.id
      ORDER BY ec.created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error('è·å–è€ƒè¯•åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'è·å–è€ƒè¯•åˆ†ç±»å¤±è´¥' });
  }
});

// åˆ›å»ºè€ƒè¯•åˆ†ç±»
fastify.post('/api/exam-categories', async (request, reply) => {
  const { name, description, icon } = request.body;

  try {
    const [result] = await pool.query(
      'INSERT INTO exam_categories (name, description, icon) VALUES (?, ?, ?)',
      [name, description || null, icon || 'ğŸ“']
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error('åˆ›å»ºè€ƒè¯•åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'åˆ›å»ºè€ƒè¯•åˆ†ç±»å¤±è´¥' });
  }
});

// æ›´æ–°è€ƒè¯•åˆ†ç±»
fastify.put('/api/exam-categories/:id', async (request, reply) => {
  const { id } = request.params;
  const { name, description, icon } = request.body;

  try {
    await pool.query(
      'UPDATE exam_categories SET name = ?, description = ?, icon = ? WHERE id = ?',
      [name, description || null, icon || 'ğŸ“', id]
    );
    return { success: true };
  } catch (error) {
    console.error('æ›´æ–°è€ƒè¯•åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'æ›´æ–°è€ƒè¯•åˆ†ç±»å¤±è´¥' });
  }
});

// åˆ é™¤è€ƒè¯•åˆ†ç±»
fastify.delete('/api/exam-categories/:id', async (request, reply) => {
  const { id } = request.params;

  try {
    // å°†å…³è”çš„è€ƒè¯•ï¿½?category_id è®¾ç½®ï¿½?NULL
    await pool.query('UPDATE exams SET category_id = NULL WHERE category_id = ?', [id]);

    // åˆ é™¤åˆ†ç±»
    await pool.query('DELETE FROM exam_categories WHERE id = ?', [id]);

    return { success: true };
  } catch (error) {
    console.error('åˆ é™¤è€ƒè¯•åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'åˆ é™¤è€ƒè¯•åˆ†ç±»å¤±è´¥' });
  }
});

// å¢åŠ æ–‡æ¡£æµè§ˆé‡
fastify.post('/api/knowledge/articles/:id/view', async (request, reply) => {
  const { id } = request.params
  try {
    await pool.query('UPDATE knowledge_articles SET view_count = view_count + 1 WHERE id = ?', [id])
    return { success: true }
  } catch (error) {
    console.error(error)
    reply.code(500).send({ error: 'Failed to update view count' })
  }
})

// æ–‡æ¡£ç‚¹èµ
fastify.post('/api/knowledge/articles/:id/like', async (request, reply) => {
  const { id } = request.params;
  const { userId } = request.body; // ä»è¯·æ±‚ä½“è·å–ç”¨æˆ·ID

  try {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»ç‚¹èµè¿‡
    const [existing] = await pool.query(
      'SELECT id FROM article_likes WHERE article_id = ? AND user_id = ?',
      [id, userId || 'anonymous']
    );

    if (existing.length > 0) {
      return reply.code(400).send({ success: false, message: 'æ‚¨å·²ç»ç‚¹èµè¿‡' });
    }

    // è®°å½•ç‚¹èµ
    await pool.query(
      'INSERT INTO article_likes (article_id, user_id) VALUES (?, ?)',
      [id, userId || 'anonymous']
    );

    // æ›´æ–°ç‚¹èµæ•°
    await pool.query('UPDATE knowledge_articles SET like_count = like_count + 1 WHERE id = ?', [id]);

    return { success: true, message: 'ç‚¹èµæˆåŠŸ' };
  } catch (error) {
    console.error(error);
    // å¦‚æœè¡¨ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºè¡¨
    if (error.code === 'ER_NO_SUCH_TABLE') {
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS article_likes (
            id INT PRIMARY KEY AUTO_INCREMENT,
            article_id INT NOT NULL,
            user_id VARCHAR(50) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE KEY unique_like (article_id, user_id),
            INDEX idx_article (article_id),
            INDEX idx_user (user_id)
          )
        `);
        // é‡è¯•ç‚¹èµ
        return reply.redirect(307, request.url);
      } catch (createError) {
        console.error('åˆ›å»ºç‚¹èµè¡¨å¤±è´¥', createError);
      }
    }
    reply.code(500).send({ error: 'Failed to update like count' });
  }
});

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç‚¹èµ
fastify.get('/api/knowledge/articles/:id/liked', async (request, reply) => {
  const { id } = request.params;
  const { userId } = request.query;

  try {
    const [existing] = await pool.query(
      'SELECT id FROM article_likes WHERE article_id = ? AND user_id = ?',
      [id, userId || 'anonymous']
    );

    return { liked: existing.length > 0 };
  } catch (error) {
    console.error(error);
    return { liked: false };
  }
});

// è·å–æˆ‘çš„åˆ†ç±»ï¼ˆç”¨æˆ·åˆ›å»ºçš„åˆ†ç±»ï¼‰
fastify.get('/api/my-knowledge/categories', async (request, reply) => {
  try {
    // å¦‚æœæ²¡æœ‰ç”¨æˆ·è®¤è¯ï¼Œè¿”å›æ‰€æœ‰åˆ†ç±»
    const userId = request.user?.id || null;

    let query = `
      SELECT * FROM knowledge_categories
      WHERE deleted_at IS NULL
    `;
    const params = [];

    if (userId) {
      query += ` AND created_by = ?`;
      params.push(userId);
    }

    query += ` ORDER BY sort_order, created_at DESC`;

    const [rows] = await pool.query(query, params);
    return rows;
  } catch (error) {
    console.error('è·å–æˆ‘çš„åˆ†ç±»å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to fetch my categories' });
  }
});

// è·å–æˆ‘çš„æ–‡æ¡£ï¼ˆç”¨æˆ·åˆ›å»ºçš„æ–‡æ¡£ï¼‰
fastify.get('/api/my-knowledge/articles', async (request, reply) => {
  try {
    // å¦‚æœæ²¡æœ‰ç”¨æˆ·è®¤è¯ï¼Œè¿”å›æ‰€æœ‰æ–‡æ¡£
    const userId = request.user?.id || null;

    let query = `
      SELECT
        ka.*,
        kc.name as category_name,
        u.real_name as author_name
      FROM knowledge_articles ka
      LEFT JOIN knowledge_categories kc ON ka.category_id = kc.id
      LEFT JOIN users u ON ka.created_by = u.id
      WHERE ka.status != 'deleted'
    `;
    const params = [];

    if (userId) {
      query += ` AND ka.created_by = ?`;
      params.push(userId);
    }

    query += ` ORDER BY ka.created_at DESC`;

    const [rows] = await pool.query(query, params);
    return rows;
  } catch (error) {
    console.error('è·å–æˆ‘çš„æ–‡æ¡£å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to fetch my articles' });
  }
});

// ä¿å­˜æ–‡æ¡£åˆ°æˆ‘çš„çŸ¥è¯†åº“
fastify.post('/api/my-knowledge/articles/save', async (request, reply) => {
  const { articleId, categoryId, notes } = request.body;
  const userId = request.user?.id || null; // å¦‚æœæ²¡æœ‰ç”¨æˆ·IDï¼Œè®¾ä¸º null è€Œä¸æ˜¯ 'anonymous'

  try {
    // è·å–åŸæ–‡æ¡£
    const [articles] = await pool.query(
      'SELECT * FROM knowledge_articles WHERE id = ?',
      [articleId]
    );

    if (articles.length === 0) {
      return reply.code(404).send({ error: 'Article not found' });
    }

    const originalArticle = articles[0];

    // å¤„ç† attachments å­—æ®µ - ç¡®ä¿æ˜¯æœ‰æ•ˆçš„ JSON å­—ç¬¦ä¸²
    let attachmentsJson = null;
    if (originalArticle.attachments) {
      if (typeof originalArticle.attachments === 'string') {
        // å¦‚æœå·²ç»æ˜¯å­—ç¬¦ä¸²ï¼ŒéªŒè¯æ˜¯å¦æ˜¯æœ‰æ•ˆ JSON
        try {
          JSON.parse(originalArticle.attachments);
          attachmentsJson = originalArticle.attachments;
        } catch (e) {
          console.error('Invalid JSON in attachments:', originalArticle.attachments);
          attachmentsJson = null;
        }
      } else if (typeof originalArticle.attachments === 'object') {
        // å¦‚æœæ˜¯å¯¹è±¡ï¼Œè½¬æ¢ä¸º JSON å­—ç¬¦ä¸²
        attachmentsJson = JSON.stringify(originalArticle.attachments);
      }
    }

    // åˆ›å»ºå‰¯æœ¬åˆ°æˆ‘çš„çŸ¥è¯†åº“
    const [result] = await pool.query(
      `INSERT INTO knowledge_articles
      (title, category_id, summary, content, attachments, type, status, icon, created_by, notes, original_article_id)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        originalArticle.title,
        categoryId || null,
        originalArticle.summary,
        originalArticle.content,
        attachmentsJson,
        'personal', // ä¿å­˜ä¸ºä¸ªäººçŸ¥è¯†
        'published',
        originalArticle.icon || 'ğŸ“„',
        userId,
        notes || null,
        articleId // è®°å½•åŸæ–‡æ¡£ID
      ]
    );

    return {
      success: true,
      message: 'å·²ä¿å­˜åˆ°æˆ‘çš„çŸ¥è¯†åº“',
      id: result.insertId
    };
  } catch (error) {
    console.error('ä¿å­˜æ–‡æ¡£å¤±è´¥:', error);
    reply.code(500).send({ error: 'Failed to save article' });
  }
});

// é«˜çº§æœç´¢æ–‡æ¡£
fastify.post('/api/knowledge/articles/search', async (request, reply) => {
  try {
    const {
      keyword = '',
      categories = [],
      types = [],
      statuses = [],
      authors = [],
      dateFrom = null,
      dateTo = null,
      sortBy = 'created_at',
      sortOrder = 'DESC',
      page = 1,
      pageSize = 20
    } = request.body;

    let query = `
      SELECT
        ka.*,
        kc.name as category_name,
        u.real_name as author_name
      FROM knowledge_articles ka
      LEFT JOIN knowledge_categories kc ON ka.category_id = kc.id
      LEFT JOIN users u ON ka.created_by = u.id
      WHERE ka.status != 'deleted'
    `;
    const params = [];

    // å…³é”®è¯æœç´¢
    if (keyword && keyword.trim() !== '') {
      query += ` AND (ka.title LIKE ? OR ka.content LIKE ? OR ka.summary LIKE ?)`;
      const keywordParam = `%${keyword}%`;
      params.push(keywordParam, keywordParam, keywordParam);
    }

    // åˆ†ç±»ç­›é€‰
    if (categories && categories.length > 0) {
      query += ` AND ka.category_id IN (${categories.map(() => '?').join(',')})`;
      params.push(...categories);
    }

    // ç±»å‹ç­›é€‰
    if (types && types.length > 0) {
      query += ` AND ka.type IN (${types.map(() => '?').join(',')})`;
      params.push(...types);
    }

    // çŠ¶æ€ç­›é€‰
    if (statuses && statuses.length > 0) {
      query += ` AND ka.status IN (${statuses.map(() => '?').join(',')})`;
      params.push(...statuses);
    }

    // ä½œè€…ç­›é€‰
    if (authors && authors.length > 0) {
      query += ` AND ka.created_by IN (${authors.map(() => '?').join(',')})`;
      params.push(...authors);
    }

    // æ—¥æœŸèŒƒå›´ç­›é€‰
    if (dateFrom) {
      query += ` AND ka.created_at >= ?`;
      params.push(dateFrom);
    }
    if (dateTo) {
      query += ` AND ka.created_at <= ?`;
      params.push(dateTo);
    }

    // æ’åº
    const validSortFields = ['created_at', 'updated_at', 'view_count', 'like_count', 'title'];
    const validSortOrders = ['ASC', 'DESC'];
    const finalSortBy = validSortFields.includes(sortBy) ? sortBy : 'created_at';
    const finalSortOrder = validSortOrders.includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';
    query += ` ORDER BY ka.${finalSortBy} ${finalSortOrder}`;

    // åˆ†é¡µ
    const offset = (page - 1) * pageSize;
    query += ` LIMIT ? OFFSET ?`;
    params.push(pageSize, offset);

    const [rows] = await pool.query(query, params);

    // è·å–æ€»æ•°
    let countQuery = `
      SELECT COUNT(*) as total
      FROM knowledge_articles ka
      WHERE ka.status != 'deleted'
    `;
    const countParams = [];

    if (keyword && keyword.trim() !== '') {
      countQuery += ` AND (ka.title LIKE ? OR ka.content LIKE ? OR ka.summary LIKE ?)`;
      const keywordParam = `%${keyword}%`;
      countParams.push(keywordParam, keywordParam, keywordParam);
    }
    if (categories && categories.length > 0) {
      countQuery += ` AND ka.category_id IN (${categories.map(() => '?').join(',')})`;
      countParams.push(...categories);
    }
    if (types && types.length > 0) {
      countQuery += ` AND ka.type IN (${types.map(() => '?').join(',')})`;
      countParams.push(...types);
    }
    if (statuses && statuses.length > 0) {
      countQuery += ` AND ka.status IN (${statuses.map(() => '?').join(',')})`;
      countParams.push(...statuses);
    }
    if (authors && authors.length > 0) {
      countQuery += ` AND ka.created_by IN (${authors.map(() => '?').join(',')})`;
      countParams.push(...authors);
    }
    if (dateFrom) {
      countQuery += ` AND ka.created_at >= ?`;
      countParams.push(dateFrom);
    }
    if (dateTo) {
      countQuery += ` AND ka.created_at <= ?`;
      countParams.push(dateTo);
    }

    const [countResult] = await pool.query(countQuery, countParams);
    const total = countResult[0].total;

    return {
      success: true,
      data: rows,
      pagination: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize)
      }
    };
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    reply.code(500).send({ error: 'Search failed: ' + error.message });
  }
});

// ==================== æƒé™ç®¡ç† API ====================

// è·å–æ‰€æœ‰è§’è‰²åˆ—è¡¨
fastify.get('/api/roles', async (request, reply) => {
  try {
    const [rows] = await pool.query(`
      SELECT
        r.*,
        COUNT(DISTINCT ur.user_id) as user_count,
        COUNT(DISTINCT rp.permission_id) as permission_count
      FROM roles r
      LEFT JOIN user_roles ur ON r.id = ur.role_id
      LEFT JOIN role_permissions rp ON r.id = rp.role_id
      GROUP BY r.id
      ORDER BY r.level DESC, r.created_at DESC
    `);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch roles' });
  }
});

// åˆ›å»ºè§’è‰²
fastify.post('/api/roles', async (request, reply) => {
  const { name, description, level, can_view_all_departments } = request.body;
  try {
    const [result] = await pool.query(
      'INSERT INTO roles (name, description, level, is_system, can_view_all_departments) VALUES (?, ?, ?, 0, ?)',
      [name, description || null, level || 1, can_view_all_departments || 0]
    );
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to create role' });
  }
});

// æ›´æ–°è§’è‰²
fastify.put('/api/roles/:id', async (request, reply) => {
  const { id } = request.params;
  const { name, description, level, can_view_all_departments } = request.body;
  try {
    // æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿè§’è‰²
    const [roleRows] = await pool.query('SELECT is_system FROM roles WHERE id = ?', [id]);

    if (roleRows.length > 0 && roleRows[0].is_system === 1) {
      // ç³»ç»Ÿè§’è‰²åªå…è®¸ä¿®æ”¹ can_view_all_departments å­—æ®µ
      await pool.query(
        'UPDATE roles SET can_view_all_departments = ? WHERE id = ?',
        [can_view_all_departments || 0, id]
      );
      return { success: true, message: 'ç³»ç»Ÿè§’è‰²åªèƒ½ä¿®æ”¹éƒ¨é—¨æŸ¥çœ‹æƒé™' };
    }

    // éç³»ç»Ÿè§’è‰²å¯ä»¥ä¿®æ”¹æ‰€æœ‰å­—æ®µ
    await pool.query(
      'UPDATE roles SET name = ?, description = ?, level = ?, can_view_all_departments = ? WHERE id = ?',
      [name, description || null, level || 1, can_view_all_departments || 0, id]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to update role' });
  }
});

// åˆ é™¤è§’è‰²
fastify.delete('/api/roles/:id', async (request, reply) => {
  const { id } = request.params;
  try {
    // æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿè§’è‰²
    const [roleRows] = await pool.query('SELECT is_system FROM roles WHERE id = ?', [id]);
    if (roleRows.length > 0 && roleRows[0].is_system === 1) {
      return reply.code(403).send({ error: 'Cannot delete system role' });
    }

    await pool.query('DELETE FROM roles WHERE id = ?', [id]);
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to delete role' });
  }
});

// è·å–æ‰€æœ‰æƒé™åˆ—è¡¨
fastify.get('/api/permissions', async (request, reply) => {
  try {
    const [rows] = await pool.query('SELECT * FROM permissions ORDER BY module, id');
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch permissions' });
  }
});

// è·å–è§’è‰²çš„æƒé™åˆ—è¡¨
fastify.get('/api/roles/:id/permissions', async (request, reply) => {
  const { id } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT p.*
      FROM permissions p
      INNER JOIN role_permissions rp ON p.id = rp.permission_id
      WHERE rp.role_id = ?
      ORDER BY p.module, p.id
    `, [id]);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch role permissions' });
  }
});

// ä¸ºè§’è‰²æ·»åŠ æƒé™
fastify.post('/api/roles/:id/permissions', async (request, reply) => {
  const { id } = request.params;
  const { permission_id } = request.body;
  try {
    await pool.query(
      'INSERT IGNORE INTO role_permissions (role_id, permission_id) VALUES (?, ?)',
      [id, permission_id]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to add permission' });
  }
});

// ç§»é™¤è§’è‰²çš„æƒé™
fastify.delete('/api/roles/:roleId/permissions/:permissionId', async (request, reply) => {
  const { roleId, permissionId } = request.params;
  try {
    await pool.query(
      'DELETE FROM role_permissions WHERE role_id = ? AND permission_id = ?',
      [roleId, permissionId]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to remove permission' });
  }
});

// ==================== è§’è‰²éƒ¨é—¨æƒé™ç®¡ç† API ====================

// è·å–è§’è‰²çš„éƒ¨é—¨æƒé™åˆ—è¡¨
fastify.get('/api/roles/:id/departments', async (request, reply) => {
  const { id } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT d.*
      FROM departments d
      INNER JOIN role_departments rd ON d.id = rd.department_id
      WHERE rd.role_id = ?
      ORDER BY d.sort_order, d.id
    `, [id]);
    return { success: true, data: rows };
  } catch (error) {
    console.error('è·å–è§’è‰²éƒ¨é—¨æƒé™å¤±è´¥:', error);
    reply.code(500).send({ success: false, error: 'Failed to fetch role departments' });
  }
});

// ä¸ºè§’è‰²æ·»åŠ éƒ¨é—¨æƒé™
fastify.post('/api/roles/:id/departments', async (request, reply) => {
  const { id } = request.params;
  const { department_id } = request.body;
  try {
    await pool.query(
      'INSERT IGNORE INTO role_departments (role_id, department_id) VALUES (?, ?)',
      [id, department_id]
    );
    return { success: true, message: 'éƒ¨é—¨æƒé™æ·»åŠ æˆåŠŸ' };
  } catch (error) {
    console.error('æ·»åŠ è§’è‰²éƒ¨é—¨æƒé™å¤±è´¥:', error);
    reply.code(500).send({ success: false, error: 'Failed to add department permission' });
  }
});

// æ‰¹é‡è®¾ç½®è§’è‰²çš„éƒ¨é—¨æƒé™
fastify.put('/api/roles/:id/departments', async (request, reply) => {
  const { id } = request.params;
  const { department_ids } = request.body; // éƒ¨é—¨IDæ•°ç»„

  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();

    try {
      // 1. åˆ é™¤è¯¥è§’è‰²çš„æ‰€æœ‰éƒ¨é—¨æƒé™
      await connection.query('DELETE FROM role_departments WHERE role_id = ?', [id]);

      // 2. æ‰¹é‡æ·»åŠ æ–°çš„éƒ¨é—¨æƒé™
      if (department_ids && department_ids.length > 0) {
        const values = department_ids.map(deptId => [id, deptId]);
        await connection.query(
          'INSERT INTO role_departments (role_id, department_id) VALUES ?',
          [values]
        );
      }

      await connection.commit();
      connection.release();

      return {
        success: true,
        message: 'éƒ¨é—¨æƒé™è®¾ç½®æˆåŠŸ',
        count: department_ids?.length || 0
      };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('æ‰¹é‡è®¾ç½®è§’è‰²éƒ¨é—¨æƒé™å¤±è´¥:', error);
    reply.code(500).send({ success: false, error: 'Failed to update department permissions' });
  }
});

// ç§»é™¤è§’è‰²çš„éƒ¨é—¨æƒé™
fastify.delete('/api/roles/:roleId/departments/:departmentId', async (request, reply) => {
  const { roleId, departmentId } = request.params;
  try {
    await pool.query(
      'DELETE FROM role_departments WHERE role_id = ? AND department_id = ?',
      [roleId, departmentId]
    );
    return { success: true, message: 'éƒ¨é—¨æƒé™ç§»é™¤æˆåŠŸ'};
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to remove permission' });
  }
});

// è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…å«è§’è‰²ä¿¡æ¯ï¼‰
fastify.get('/api/users-with-roles', async (request, reply) => {
  try {
    const [users] = await pool.query(`
      SELECT
        u.id,
        u.username,
        u.real_name,
        u.email,
        u.phone,
        u.status,
        u.department_id,
        d.name as department_name
      FROM users u
      LEFT JOIN departments d ON u.department_id = d.id
      ORDER BY u.created_at DESC
    `);

    // ä¸ºæ¯ä¸ªç”¨æˆ·è·å–è§’è‰²
    for (let user of users) {
      const [roles] = await pool.query(`
        SELECT r.id, r.name, r.level
        FROM roles r
        INNER JOIN user_roles ur ON r.id = ur.role_id
        WHERE ur.user_id = ?
        ORDER BY r.level DESC
      `, [user.id]);
      user.roles = roles;
    }

    return users;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch users' });
  }
});

// è·å–ç”¨æˆ·çš„è§’è‰²åˆ—è¡¨
fastify.get('/api/users/:id/roles', async (request, reply) => {
  const { id } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT r.*
      FROM roles r
      INNER JOIN user_roles ur ON r.id = ur.role_id
      WHERE ur.user_id = ?
      ORDER BY r.level DESC
    `, [id]);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch user roles' });
  }
});

// ä¸ºç”¨æˆ·åˆ†é…è§’è‰²
fastify.post('/api/users/:id/roles', async (request, reply) => {
  const { id } = request.params;
  const { role_id } = request.body;
  try {
    await pool.query(
      'INSERT IGNORE INTO user_roles (user_id, role_id, assigned_by) VALUES (?, ?, ?)',
      [id, role_id, request.user?.id || null]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to assign role' });
  }
});

// ç§»é™¤ç”¨æˆ·çš„è§’è‰²
fastify.delete('/api/users/:userId/roles/:roleId', async (request, reply) => {
  const { userId, roleId } = request.params;
  try {
    await pool.query(
      'DELETE FROM user_roles WHERE user_id = ? AND role_id = ?',
      [userId, roleId]
    );
    return { success: true };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to remove role' });
  }
});

// è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™ï¼ˆé€šè¿‡è§’è‰²ï¼‰
fastify.get('/api/users/:id/permissions', async (request, reply) => {
  const { id } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT DISTINCT p.*
      FROM permissions p
      INNER JOIN role_permissions rp ON p.id = rp.permission_id
      INNER JOIN user_roles ur ON rp.role_id = ur.role_id
      WHERE ur.user_id = ?
      ORDER BY p.module, p.id
    `, [id]);
    return rows;
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to fetch user permissions' });
  }
});

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æŸä¸ªæƒé™
fastify.get('/api/users/:id/has-permission/:code', async (request, reply) => {
  const { id, code } = request.params;
  try {
    const [rows] = await pool.query(`
      SELECT COUNT(*) as count
      FROM permissions p
      INNER JOIN role_permissions rp ON p.id = rp.permission_id
      INNER JOIN user_roles ur ON rp.role_id = ur.role_id
      WHERE ur.user_id = ? AND p.code = ?
    `, [id, code]);
    return { hasPermission: rows[0].count > 0 };
  } catch (error) {
    console.error(error);
    reply.code(500).send({ error: 'Failed to check permission' });
  }
});

// ==================== å¯åŠ¨æœåŠ¡ ====================

// ==================== è€ƒå‹¤ç®¡ç†è·¯ç”± ====================
fastify.register(require('./routes/attendance-clock'));
fastify.register(require('./routes/leave'));
fastify.register(require('./routes/overtime'));
fastify.register(require('./routes/makeup'));
fastify.register(require('./routes/attendance-stats'));
fastify.register(require('./routes/shifts'));
fastify.register(require('./routes/schedules'));
fastify.register(require('./routes/schedule-excel'));
fastify.register(require('./routes/attendance-approval'));

// ==================== å¢å¼ºåŠŸèƒ½è·¯ç”± ====================
fastify.register(require('./routes/export'));
fastify.register(require('./routes/notifications'));
fastify.register(require('./routes/smart-schedule'));

// ==================== èŒä½ç®¡ç†è·¯ç”± ====================
fastify.register(require('./routes/positions'))

// ==================== éƒ¨é—¨ç®¡ç†è·¯ç”± ====================
fastify.register(require('./routes/departments'))

console.log('âœ… è€ƒå‹¤ç®¡ç†è·¯ç”±å·²æ³¨å†Œ');
console.log('âœ… å¢å¼ºåŠŸèƒ½è·¯ç”±å·²æ³¨å†Œï¼ˆåŒ…å«æ’ç­Excelå¯¼å…¥å¯¼å‡ºï¼‰');
console.log('âœ… èŒä½ç®¡ç†è·¯ç”±å·²æ³¨å†Œ');
console.log('âœ… éƒ¨é—¨ç®¡ç†è·¯ç”±å·²æ³¨å†Œ');

const start = async () => {
  try {
    await initDatabase();
    await fastify.listen({ port: 3001, host: '0.0.0.0' });
    console.log('Fastify server listening on http://localhost:3001');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start()
